# SliTaz package receipt.

PACKAGE="linux"
VERSION="4.9.4"
KBASEVER="4.9"
CATEGORY="base-system"
SHORT_DESC="The Linux Kernel and modules"
MAINTAINER="devel@slitaz.org"
LICENSE="GPL2"
WEB_SITE="https://www.kernel.org/"
HOST_ARCH="i486 arm x86_64"

TARBALL="$PACKAGE-$KBASEVER.tar.xz"
WGET_URL="https://www.kernel.org/pub/linux/kernel/v4.x/$TARBALL"

DEPENDS="kmod"
BUILD_DEPENDS="slitaz-toolchain perl git xz lzma patch kmod bc"
SPLIT="lguest linux-acpi linux-agp linux-aoe linux-appletalk linux-arcnet \
linux-autofs linux-bluetooth linux-bridge linux-btrfs linux-cifs linux-coda \
linux-cpufreq linux-cramfs linux-crypto linux-cryptoloop linux-dialup \
linux-dlm linux-drm linux-ecryptfs linux-efi linux-ethernet linux-exofs \
linux-firewire linux-firmware linux-gfs2 linux-hfs linux-hfsplus linux-hid \
linux-hwmon linux-ide linux-input-misc linux-input-tablet \
linux-input-touchscreen linux-ipv6 linux-irda linux-isdn linux-jfs \
linux-joystick linux-kvm linux-logfs linux-md linux-media linux-memstick \
linux-minix linux-mmc linux-module-headers linux-mwave linux-nbd linux-ncpfs \
linux-netfilter linux-nfc linux-nfs linux-nfsd linux-ocfs2 linux-orangefs \
linux-radio linux-reiserfs linux-romfs linux-sched linux-scsi linux-sound \
linux-source linux-speakup linux-squashfs linux-staging linux-toshiba \
linux-usb-gadget linux-usb-misc linux-usbdsl linux-usbip linux-uwb linux-video \
linux-wan linux-watchdog linux-wimax linux-wireless linux-without-modules \
linux-zram"
SIBLINGS="linux-api-headers linux-dev linux-man"

if [ "$KBASEVER" != "${VERSION%.0}" ]; then
	PATCH="$(dirname $WGET_URL)/patch-$VERSION.xz"
	EXTRA_SOURCE_FILES="$(basename $PATCH)"
fi

#
# The Linux receipt handle cross compilation. For x86_64 we actually use
# the uclibc-cross-compiler-x86_64 and for ARM we use a real cross env.
# Please discuss any change and keep it simple, don't play with VERSION
# string or Kernel SUBLEVEL because depmod and Pankso don't like that!
#
# The receipt also handle some cook options for faster build:
# --nonomods : Skip bzImage without modules build
#

# Handle multiarch compilation. Less bdeps when cross-compiling for ARM
case "$ARCH" in
	arm)    BUILD_DEPENDS="xz" ;;
	x86_64) BUILD_DEPENDS="xz" ;;
esac

# Handle multiarch installation. ARM use Busybox modutils, so avoid any
# deps on kmod. SLITAZ_ARCH can have also custom post_install commands
if [ -f $root/etc/slitaz/slitaz.conf ]; then
	. $root/etc/slitaz/slitaz.conf
	case "$SLITAZ_ARCH" in
		arm) DEPENDS="" ;;
	esac
fi

# Rules to configure and make the package.
compile_rules()
{
	# Update sources to the $VERSION using base sources ($KBASEVER) and patch
	if [ "$KBASEVER" != "${VERSION%.0}" ]; then
		[ -s $SRC/$(basename $PATCH) ] || wget $PATCH -O $SRC/$(basename $PATCH)
		# don't patch twice for `cook $PACKAGE --continue`
		if [ ! -f "done.patch-$VERSION" ]; then
			xzcat $SRC/$(basename $PATCH) | patch -Np1
			touch done.patch-$VERSION
		fi
	fi

	#
	if [ -f "/usr/share/boot/initrd" ]; then
		cp /usr/share/boot/initrd initrd.cpio
	fi

	# Handle cross compilation
	case "$ARCH" in
		arm)
			echo "Compiling: $ARCH Kernel"
			make mrproper
			patch -Np1 < $stuff/$ARCH/linux-arm.patch || exit 1
			cp -f $stuff/$ARCH/linux-arm.config .config
			yes '' | make ARCH=$ARCH oldconfig
			make ARCH=$ARCH CROSS_COMPILE=${HOST_SYSTEM}- bzImage &&
			make ARCH=$ARCH CROSS_COMPILE=${HOST_SYSTEM}- modules &&
			make ARCH=$ARCH CROSS_COMPILE=${HOST_SYSTEM}- \
				INSTALL_MOD_PATH=$DESTDIR modules_install &&
			mkdir -p $DESTDIR/boot &&
			cp -a arch/arm/boot/zImage \
				$DESTDIR/boot/linux-$VERSION-slitaz-$ARCH
			#$stuff/tools/gztazmod.sh $DESTDIR/lib/modules/$VERSION-slitaz
			return 0 ;;
		x86_64)
			echo "TODO: Maybe use default? But cross compile in x86_64 chroot"
			echo "so we can remove the 64 build by uclibc-cross-compiler-x86_64"
			return 0 ;;
	esac

	# Get and apply Aufs patches
	. $stuff/tools/aufs-patches

	echo "cook:linux" > $command

	# Apply misc patches
	echo "Applying patches..."
	while read patch_file; do
		if [ -f done.$patch_file ]; then
			echo "Skipping $patch_file"; continue
		fi
		echo -e "\nApply $patch_file"
		patch -p1 -i $stuff/patches/$patch_file || return 1
		touch done.$patch_file
	done < $stuff/patches/patch.order

	# Mrproper and lguest
	echo "Making kernel proper and then build lguest..."
	make mrproper
	cd tools/lguest
	make lguest || return 1
	cd $src

	#
	# Linux Arch i386 - GCC arch i486
	#
	echo "Making x86 Kernel..."

	# Build bzImage without modules first
	if [ -z "$nonomods" ]; then
		cp -f $stuff/$PACKAGE-slitaz.config .config
		sed -i 's/CONFIG_MODULES=y/# CONFIG_MODULES is not set/' .config
		# We can't keep every driver in staging???
		sed -i \
			-e 's/^CONFIG_RTL8192/#&/' \
			-e 's/^CONFIG_R8187SE/#&/' \
			-e 's/^CONFIG_RT2870/#&/' .config

		title 'Configure bzImage without modules...'
		yes '' | make ARCH=i386 oldconfig

		title 'Building bzImage without modules...'
		make ARCH=i386 -j 4 bzImage || exit 1

		mkdir -p $DESTDIR
		mv arch/x86/boot/bzImage $DESTDIR
		mv System.map System.map-without-modules
	fi

	# Build bzImage with modules
	cp -f $stuff/$PACKAGE-slitaz.config .config

	title 'Configure bzImage with modules...'
	yes '' | make ARCH=i386 oldconfig


	title 'Building bzImage with modules...'
	make ARCH=i386 -j 4 bzImage &&
	make ARCH=i386 -j 4 modules &&
	make ARCH=i386 INSTALL_MOD_PATH=$DESTDIR     modules_install &&
	make ARCH=i386 INSTALL_HDR_PATH=$DESTDIR/usr headers_install &&

	[ -s arch/x86/boot/bzImage ] || return 1
	mkdir -p $DESTDIR/boot
	mv arch/x86/boot/bzImage $DESTDIR/boot/vmlinuz-$VERSION-slitaz

	$stuff/tools/install_module_headers.sh $DESTDIR $src $VERSION-slitaz

	ln System.map System.map-modules
	ln Module.symvers Module.symvers-modules
}

# Rules to gen a SliTaz package suitable for Tazpkg.
genpkg_rules()
{
	case "$ARCH" in
		arm)
			echo "Packing: ARM Kernel"
			cp -a $install/* $fs
			rm -f $fs/lib/modules/*/build $fs/lib/modules/*/source
			return 0 ;;
		x86_64)
			echo "TODO: use default or custom x86_64 packing"
			return 0 ;;
	esac

	# Copy the Kernel
	cp -a $install/boot $fs

	# Copy base modules
	. $stuff/tools/copy_modules.sh

	# We only need module.{order,builtin} because other map files are
	# generated by depmod in post_install
	cook_copy_files modules.order modules.builtin
	rm -rf $fs/usr

	# Pack all packages with a Kernel modules
	[ ! -d "$install/lib/modules/$VERSION-slitaz" ] && return 1
	for i in $SPLIT; do
		cook $i
	done

	# Checking for Linux Kernel modules that don't belong to any of the packages
	$stuff/tools/check_modules.sh
}

# Pre and post install commands for Tazpkg.
post_install()
{
	# Handle multiarch installation
	case "$SLITAZ_ARCH" in
		arm)
			echo "Kernel : /boot/linux-$VERSION-slitaz-$ARCH"
			echo "Modules: /lib/modules/$VERSION-slitaz"
			return 0 ;;
	esac

	# GRUB stuff.
	if [ -f "$1/boot/grub/menu.lst" ]; then
		# Current root device
		root_dev="/dev/$(lsblk | grep '/$'| grep -o '[a-z]d[a-z][0-9]*')"
		grub_part="$(( $(echo $root_dev | grep -o '[0-9]*$')-1 ))"
		# Use device.map to find grub device number
		grub_dev="$(grep $(echo $root_dev | grep -o  '^/dev/.d.' ) \
			"$1/boot/grub/device.map" | cut -f1 | sed "s/)$/.$grub_part)/g")"

		# Add and clean Kernel entries in case of upgrade for installed system.
		if ! grep -q vmlinuz-$VERSION-slitaz "$1/boot/grub/menu.lst"; then

			# Clean the old entry
			# TODO: old vmlinuz file is removed but the entry is still there.
			# So grub error:15 when selected: http://bugs.slitaz.org/?id=74

			# Add the new entry
			cat >> "$1/boot/grub/menu.lst" <<EOT

title SliTaz GNU/Linux (Kernel $VERSION-slitaz)
$grub_dev 
kernel /boot/vmlinuz-$VERSION-slitaz root=$root_dev quiet
EOT
			# Make it the default entry
			last_entry=$(( $(grep -c '^title' "$1/boot/grub/menu.lst")-1 ))
			sed -e "s/^default.*/default $last_entry/g" -i "$1/boot/grub/menu.lst"
		fi

		# Display information message.
		[ -z "$quiet" ] && cat <<EOT

----
GRUB is installed, these three lines must be in your /boot/grub/menu.lst:

title  SliTaz GNU/Linux (Kernel $VERSION-slitaz)
$grub_dev
kernel /boot/vmlinuz-$VERSION-slitaz root=$root_dev
----
EOT
	fi
	:
}
